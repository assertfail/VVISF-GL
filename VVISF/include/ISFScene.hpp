#ifndef ISFScene_hpp
#define ISFScene_hpp

#include "ISFBase.hpp"
#if defined(ISF_SDK_MAC)
#import <TargetConditionals.h>
#endif




namespace VVISF
{


using namespace std;




class ISFScene;
using ISFSceneRef = shared_ptr<ISFScene>;




class VVISF_EXPORT ISFScene : public GLScene	{
	private:
		bool			throwExceptions = false;	//	NO by default

		mutex			propertyLock;	//	locks the below two vars
		//bool			loadingInProgress = false;
		ISFDocRef		doc = nullptr;	//	the ISFDoc being used

		//	access to these vars should be restricted by the 'renderLock' var inherited from GLScene
		VVGL::Size		renderSize = orthoSize;	//	the last size at which i was requested to render a buffer (used to produce vals from normalized point inputs that need a render size to be used)
		Timestamper		timestamper;	//	used to generate time values, some of which get passed to the ISF scene
		uint32_t		renderFrameIndex = 0;	//	used to pass FRAMEINDEX to shaders
		double			renderTime = 0.;	//	this is the render time that gets passed to the ISF
		double			renderTimeDelta = 0.;	//	this is the render time delta (frame duration) which gets passed to the ISF
		uint32_t		passIndex = 1;	//	used to store the index of the rendered pass, which gets passed to the shader
		string			*compiledInputTypeString = nullptr;	//	a sequence of characters, either "2" or "R" or "C", one character for each input image. describes whether the shader was compiled to work with 2D textures or RECT textures or cube textures.

		//	access to these vars should be restricted by the 'renderLock' var inherited from GLScene
		GLCachedAttrib	vertexAttrib = GLCachedAttrib("VERTEXDATA");	//	caches the location of the attribute in the compiled GL program for the vertex input
		GLCachedUni		renderSizeUni = GLCachedUni("RENDERSIZE");	//	caches the location of the uniform in the compiled GL program for the render size
		GLCachedUni		passIndexUni = GLCachedUni("PASSINDEX");	//	caches the location of the uniform in the compiled GL program for the pass index
		GLCachedUni		timeUni = GLCachedUni("TIME");	//	caches the location of the uniform in the compiled GL program for the time
		GLCachedUni		timeDeltaUni = GLCachedUni("TIMEDELTA");	//	caches the location of the uniform in the compiled GL program for the time delta
		GLCachedUni		dateUni = GLCachedUni("DATE");	//	caches the location of the uniform in the compiled GL program for the date
		GLCachedUni		renderFrameIndexUni = GLCachedUni("FRAMEINDEX");	//	caches the location of the uniform in the compiled GL program for the frame index

		//	access to these vars should be restricted by the 'renderLock' var inherited from GLScene
		//GLBufferRef		geoXYVBO = nullptr;
#if !defined(ISF_TARGETENV_GLES)
		GLBufferRef		vao = nullptr;
#endif
		GLBufferRef		vbo = nullptr;
		Quad<VertXY>		vboContents;	//	the VBO owned by VAO is described by this var- we check this, and if there's a delta then we have to upload new data to the VBO

		//	these vars describe some non-default/non-standard options for more unusual situations
		bool				alwaysRenderToFloat = false;	//	false by default- if true, all interim buffers generated by the ISF will be float32 per component.  set this before loading the doc.
		bool				persistentToIOSurface = false;	//	false by default- if true, persistent buffers generated by the ISF will be backed by IOSurfaces (so they can be re-used if the underlying GL context changes to one in a different sharegroup).  set this before loading the doc.
		GLBufferPoolRef	privatePool = nullptr;	//	by default this is null and the scene will try to use the global buffer pool to create interim resources (temp/persistent buffers).  if non-null, the scene will use this pool to create interim resources.
		GLBufferCopierRef	privateCopier = nullptr;	//	by default this is null and the scene will try to use the global buffer copier to create interim resources.  if non-null, the scene will use this copier to create interim resources.

	public:
		ISFScene();
		ISFScene(const GLContextRef & inCtx);
		virtual ~ISFScene();

		virtual void prepareToBeDeleted();

		void useFile();
		void useFile(const string & inPath);
		void useDoc(ISFDocRef & inDoc);
		string getFilePath();
		string getFileName();
		string getFileDescription();
		string getFileCredit();
		ISFFileType getFileType();
		vector<string> getFileCategories();

		void setAlwaysRenderToFloat(const bool & n) { alwaysRenderToFloat=n; }
		bool getAlwaysRenderToFloat() { return alwaysRenderToFloat; }
		void setPersistentToIOSurface(const bool & n) { persistentToIOSurface=n; }
		bool getPersistentToIOSurface() { return persistentToIOSurface; }
		void setPrivatePool(const GLBufferPoolRef & n) { privatePool=n; }
		GLBufferPoolRef getPrivatePool() { return privatePool; }
		void setPrivateCopier(const GLBufferCopierRef & n) { privateCopier=n; }
		GLBufferCopierRef getPrivateCopier() { return privateCopier; }

		void setBufferForInputNamed(const GLBufferRef & inBuffer, const string & inName);
		void setFilterInputBuffer(const GLBufferRef & inBuffer);
		void setBufferForInputImageKey(const GLBufferRef & inBuffer, const string & inString);
		void setBufferForAudioInputKey(const GLBufferRef & inBuffer, const string & inString);
		GLBufferRef getBufferForImageInput(const string & inKey);
		GLBufferRef getBufferForAudioInput(const string & inKey);
		GLBufferRef getPersistentBufferNamed(const string & inKey);
		GLBufferRef getTempBufferNamed(const string & inKey);

		void setValueForInputNamed(const ISFVal & inVal, const string & inName);
		ISFVal valueForInputNamed(const string & inName);

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Woverloaded-virtual"
		//virtual GLBufferRef createAndRenderABuffer(const VVGL::Size & inSize=VVGL::Size(640.,480.), const GLBufferPoolRef & inPool=GetGlobalBufferPool());
		virtual GLBufferRef createAndRenderABuffer(const VVGL::Size & inSize=VVGL::Size(640.,480.), map<int32_t,GLBufferRef> * outPassDict=nullptr, const GLBufferPoolRef & inPoolRef=GetGlobalBufferPool());
		//virtual GLBufferRef createAndRenderABuffer(const VVGL::Size & inSize, const double & inRenderTime, const GLBufferPoolRef & inPoolRef=GetGlobalBufferPool());
		virtual GLBufferRef createAndRenderABuffer(const VVGL::Size & inSize, const double & inRenderTime, map<int32_t,GLBufferRef> * outPassDict=nullptr, const GLBufferPoolRef & inPoolRef=GetGlobalBufferPool());
#pragma clang diagnostic pop

		void renderToBuffer(const GLBufferRef & inTargetBuffer, const VVGL::Size & inRenderSize, const double & inRenderTime, map<int32_t,GLBufferRef> * outPassDict);
		void renderToBuffer(const GLBufferRef & inTargetBuffer, const VVGL::Size & inRenderSize, const double & inRenderTime);
		void renderToBuffer(const GLBufferRef & inTargetBuffer, const VVGL::Size & inRenderSize, map<int32_t,GLBufferRef> * outPassDict);
		void renderToBuffer(const GLBufferRef & inTargetBuffer, const VVGL::Size & inRenderSize);
		void renderToBuffer(const GLBufferRef & inTargetBuffer);

		virtual void setSize(const VVGL::Size & n);
		VVGL::Size getSize() const { return orthoSize; }
		VVGL::Size getRenderSize() const { return renderSize; }
		inline Timestamp getTimestamp() { return timestamper.nowTime(); }
		inline void setThrowExceptions(const bool & n) { throwExceptions=n; }

		//virtual void renderToBuffer(const GLBufferRef & inTargetBuffer, const VVGL::Size & inRenderSize=VVGL::Size(640.,480.), const double & inRenderTime=timestamper.nowTime().getTimeInSeconds(), map<string,GLBufferRef> * outPassDict=nullptr);

		ISFAttrRef getInputNamed(const string & inName);
		vector<ISFAttrRef> getInputs();
		vector<ISFAttrRef> getInputs(const ISFValType & inType);
		vector<ISFAttrRef> getImageInputs();
		vector<ISFAttrRef> getAudioInputs();
		vector<ISFAttrRef> getImageImports();

		inline ISFDocRef getDoc() { lock_guard<mutex> lock(propertyLock); return doc; }

		virtual void setVertexShaderString(const string & n);
		virtual void setFragmentShaderString(const string & n);

	protected:
#if !defined(ISF_TARGETENV_GLES)
		inline GLBufferRef getVAO() const { return vao; }
		inline void setVAO(const GLBufferRef & n) { vao = n; }
#endif
		inline GLBufferRef getVBO() const { return vbo; }
		inline void setVBO(const GLBufferRef & n) { vbo = n; }
		void _setUpRenderCallback();
		virtual void _renderPrep();
		virtual void _initialize();
		virtual void _renderCleanup();
		virtual void _render(const GLBufferRef & inTargetBuffer, const VVGL::Size & inSize, const double & inTime, map<int32_t,GLBufferRef> * outPassDict);

};




inline ISFSceneRef CreateISFSceneRef() { return make_shared<ISFScene>(); }
inline ISFSceneRef CreateISFSceneRefUsing(const GLContextRef & inCtx) { return make_shared<ISFScene>(inCtx); }




}




#endif /* ISFScene_hpp */
